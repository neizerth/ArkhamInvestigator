# Анализ производительности после оптимизации Vec<u8>

## Текущие результаты (release build)
- **Время выполнения**: 8.55 секунд ✅ (проходит лимит 10 секунд)
- **Итераций**: 1,751,410
- **Вызовов multinomial**: 1,417,636
- **Клонирований Vec**: 7,753,740
- **Построений ключей кэша**: 5,294,506
- **Финальных записей**: 1,417,644

## Оставшиеся проблемы

### 1. Клонирование Vec (7.7M раз) - КРИТИЧНО
**Проблема**: В строках 180 и 188 `get_chaos_bag_modifiers.rs` происходит клонирование Vec на каждой итерации:
```rust
let mut next_available_map = item.available_map.clone();  // строка 180
let mut next_reveal_map = item.reveal_map.clone();        // строка 188
```

**Масштаб**: 7.7 миллиона клонирований. Хотя клонирование Vec<u8> быстрее HashMap, это все еще очень дорого.

**Решение**: 
- Использовать `Rc<Vec<u8>>` для неизменяемых данных
- Или использовать copy-on-write семантику
- Или оптимизировать алгоритм, чтобы избежать клонирования

### 2. Построение строковых ключей кэша (5.3M раз) - КРИТИЧНО
**Проблема**: Функция `build_cache_key` вызывается 5.3 миллиона раз и выполняет:
```rust
pub fn build_cache_key(
    reveal_map: &[u8],
    available_count: usize,
    modifier: i16,
) -> String {
    let mut parts = Vec::new();
    for (idx, &val) in reveal_map.iter().enumerate() {
        if val > 0 {
            parts.push(format!("{}:{}", idx, val));  // форматирование строк
        }
    }
    format!("{}|{}|{}", parts.join(","), available_count, modifier)  // конкатенация
}
```

**Масштаб**: 5.3 миллиона вызовов, каждый создает:
- Vec для parts
- Множество строк через format!
- Конкатенацию строк

**Решение**: 
- Использовать кортеж `(Vec<u8>, usize, i16)` как ключ (но нужно реализовать Hash)
- Или использовать более эффективный способ создания ключа (например, через хэш)
- Или использовать структуру, которая реализует Hash напрямую

### 3. Избыточное клонирование (строка 217)
**Проблема**: 
```rust
cache_map.insert(key, new_item.clone());  // клонирование перед вставкой
items_to_process.push(new_item);
```

**Решение**: Убрать клонирование, так как `new_item` уже перемещается в `items_to_process`.

### 4. Двойной вызов ensure_vec_size
**Проблема**: `ensure_vec_size` вызывается дважды на каждой итерации (строки 181 и 189).

**Решение**: Объединить в одну функцию или оптимизировать.

## План оптимизации

### Приоритет 1: Замена строковых ключей на эффективные
- Использовать структуру ключа, которая реализует Hash и PartialEq
- Или использовать кортеж с кастомным Hash

### Приоритет 2: Минимизация клонирования Vec
- Использовать `Rc<Vec<u8>>` для неизменяемых данных
- Или оптимизировать алгоритм для уменьшения клонирований

### Приоритет 3: Убрать избыточные клонирования
- Убрать клонирование в строке 217

### Приоритет 4: Оптимизация ensure_vec_size
- Объединить вызовы или оптимизировать логику

## Ожидаемый эффект
Применение всех оптимизаций может снизить время выполнения с 8.55 секунд до 2-3 секунд.

