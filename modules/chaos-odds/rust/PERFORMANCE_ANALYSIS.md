# Анализ производительности `four_tablet_reveal_count_two_performance`

## Статистика выполнения
- **Время выполнения**: 72.26 секунд (ожидалось < 30 секунд)
- **Итераций**: 1,467,181
- **Вызовов multinomial**: 1,195,480
- **Клонирований HashMap**: 6,330,844
- **Построений ключей кэша**: 4,360,902
- **Финальных записей**: 1,195,488

## Основные узкие места

### 1. Клонирование HashMap (критично)
**Проблема**: В строках 174 и 181 `get_chaos_bag_modifiers.rs` происходит клонирование HashMap на каждой итерации:
```rust
let mut next_available_map = item.available_map.clone();  // строка 174
let mut next_reveal_map = item.reveal_map.clone();        // строка 181
```

**Масштаб**: 6.3 миллиона клонирований. Каждое клонирование HashMap требует:
- Выделения памяти для всех ключей (String)
- Выделения памяти для всех значений
- Копирования всех пар ключ-значение

**Влияние**: Это самая дорогая операция, особенно при большом количестве групп токенов.

### 2. Построение строковых ключей кэша (критично)
**Проблема**: Функция `build_cache_key` (строка 195) вызывается 4.3 миллиона раз и выполняет:
```rust
pub fn build_cache_key(
    reveal_map: &HashMap<String, usize>,
    available_count: usize,
    modifier: i16,
) -> String {
    let mut entries: Vec<(String, usize)> =
        reveal_map.iter().map(|(k, v)| (k.clone(), *v)).collect();  // клонирование всех ключей
    entries.sort_by(|a, b| a.0.cmp(&b.0));                         // сортировка
    let parts: Vec<String> = entries
        .iter()
        .map(|(k, v)| format!("{}:{}", k, v))                      // форматирование
        .collect();
    format!("{}|{}|{}", parts.join(","), available_count, modifier) // конкатенация
}
```

**Масштаб**: 4.3 миллиона вызовов, каждый из которых:
- Клонирует все ключи из HashMap
- Сортирует их
- Форматирует в строки
- Объединяет в одну строку

**Влияние**: Очень дорого для частых вызовов, особенно при большом количестве ключей в reveal_map.

### 3. Клонирование строковых ключей групп
**Проблема**: В строке 183 происходит клонирование `group.group_index`:
```rust
let entry = next_reveal_map
    .entry(group.group_index.clone())  // клонирование на каждой итерации
    .or_insert(0);
```

**Масштаб**: Происходит на каждой итерации для каждой группы, что может быть миллионы раз.

### 4. Избыточное создание состояний
**Проблема**: Алгоритм создает экспоненциально много состояний из-за каскадных раскрытий (tablet с reveal_count=2 создает цепочку раскрытий).

**Масштаб**: 1.4 миллиона итераций, что приводит к большому количеству состояний для обработки.

### 5. Mutex блокировки в multinomial
**Проблема**: Функция `multinomial` использует глобальный Mutex, который блокируется дважды на каждый вызов (для чтения и записи).

**Масштаб**: 1.2 миллиона вызовов, каждый с двумя блокировками Mutex.

## Рекомендации по оптимизации

### Приоритет 1: Оптимизация ключей кэша
**Решение**: Использовать более эффективный ключ вместо строки:
- Использовать `(u64, usize, i16)` кортеж с хэшем reveal_map
- Или использовать структуру, которая реализует Hash и PartialEq напрямую
- Избежать клонирования и форматирования строк

**Ожидаемый эффект**: Снижение времени построения ключей с ~30-40% до <5% от общего времени.

### Приоритет 2: Минимизация клонирования HashMap
**Решение**: 
- Использовать `Rc<HashMap>` для разделения неизменяемых данных
- Или использовать более эффективную структуру данных (например, Vec с индексами вместо HashMap)
- Или использовать copy-on-write семантику

**Ожидаемый эффект**: Снижение времени клонирования с ~40-50% до <10% от общего времени.

### Приоритет 3: Оптимизация multinomial
**Решение**:
- Использовать `DashMap` или другой concurrent hash map вместо Mutex
- Или использовать thread-local кэш с периодической синхронизацией

**Ожидаемый эффект**: Снижение накладных расходов на блокировки.

### Приоритет 4: Оптимизация алгоритма
**Решение**:
- Раннее объединение состояний с одинаковыми reveal_map
- Более агрессивная дедупликация состояний
- Оптимизация порядка обработки групп

**Ожидаемый эффект**: Снижение количества итераций и состояний.

## Оценка общего эффекта
Применение всех оптимизаций может снизить время выполнения с 72 секунд до 5-10 секунд.

